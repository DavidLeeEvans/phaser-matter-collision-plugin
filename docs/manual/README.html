<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../">
  <title data-ice="title">Manual | phaser-matter-collision-plugin</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<link rel="stylesheet" href="./inject/css/0-injected-style.css"><meta name="description" content="A plugin for making it easier to manage collisions with Phaser + Matter.js"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="phaser-matter-collision-plugin"><meta property="twitter:description" content="A plugin for making it easier to manage collisions with Phaser + Matter.js"></head>
<body class="layout-container manual-root" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/mikewesthad/phaser-matter-collision-plugin"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div class="manual-toc-root">
  
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/README.html"><a href="manual/README.html" data-ice="link">Phaser Matter Collision Plugin &#x1F4A5;</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/README.html"><a href="manual/README.html#installation" data-ice="link">Installation</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/README.html"><a href="manual/README.html#as-a-script" data-ice="link">As a Script</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/README.html"><a href="manual/README.html#as-a-module" data-ice="link">As a Module</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/README.html"><a href="manual/README.html#usage" data-ice="link">Usage</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/README.html"><a href="manual/README.html#initial-setup" data-ice="link">Initial Setup</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/README.html"><a href="manual/README.html#usage-in-scene" data-ice="link">Usage in Scene</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/README.html"><a href="manual/README.html#tracking-collisions" data-ice="link">Tracking Collisions</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/README.html"><a href="manual/README.html#stop-tracking-collisions" data-ice="link">Stop Tracking Collisions</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/README.html"><a href="manual/README.html#live-examples" data-ice="link">Live Examples</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/README.html"><a href="manual/README.html#development" data-ice="link">Development</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/README.html"><a href="manual/README.html#tests" data-ice="link">Tests</a></li>
</ul>
  </div>
</div>
</nav>

<div class="content" data-ice="content"><div class="github-markdown" data-ice="content"><h1 id="phaser-matter-collision-plugin-&#x1F4A5;">Phaser Matter Collision Plugin &#x1F4A5;</h1><p>A plugin for making it easier to manage collisions with the <a href="https://phaser.io/">Phaser</a> game engine and the <a href="http://brm.io/matter-js/">Matter.js</a> physics engine.</p>
<p>Matter is one of the cool physics engine choices you have in Phaser 3. Phaser has a thin wrapper over Matter&apos;s API, so you need to dig into Matter&apos;s native collision event system if you want to detect and respond to collisions. That system just gives you a dump of all the pairs of bodies that collided in a tick of the engine. This plugin wraps up that collision logic in a friendlier, more modular way:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const player = this.matter.add.sprite(0, 0, &quot;player&quot;);
const trapDoor = this.matter.add.sprite(200, 0, &quot;door&quot;);

this.matterCollision.addOnCollideStart({
  objectA: player,
  objectB: trapDoor,
  callback: () =&gt; console.log(&quot;Player touched door!&quot;)
});</code>
</code></pre>
<p>Check out the HTML documentation <a href="https://www.mikewesthad.com/phaser-matter-collision-plugin/docs/manual/README.html">here</a>.</p>
<h2 id="installation">Installation</h2><p>You can install this plugin globally as a script, or locally as a module using your bundler of choice.</p>
<h3 id="as-a-script">As a Script</h3><p>You can drop in any of the transpiled code into your project as a standalone script. Choose the version that you want:</p>
<ul>
<li><a href="https://raw.githubusercontent.com/mikewesthad/phaser-matter-collision-plugin/master/dist/phaser-matter-collision-plugin.min.js">minified code</a> &amp; optional <a href="https://raw.githubusercontent.com/mikewesthad/phaser-matter-collision-plugin/master/dist/phaser-matter-collision-plugin.min.js.map">source map</a></li>
<li><a href="https://raw.githubusercontent.com/mikewesthad/phaser-matter-collision-plugin/master/dist/phaser-matter-collision-plugin.js">unminified code</a> &amp; optional <a href="https://raw.githubusercontent.com/mikewesthad/phaser-matter-collision-plugin/master/dist/phaser-matter-collision-plugin.js.map">source map</a></li>
</ul>
<p>E.g. if you wanted the minified code, you would add this to your HTML:</p>
<pre><code class="lang-html"><code class="source-code prettyprint">&lt;script src=&quot;phaser-matter-collision-plugin.min.js&quot;&gt;&lt;/script&gt;</code>
</code></pre>
<p>Or use the jsdelivr CDN:</p>
<pre><code class="lang-html"><code class="source-code prettyprint">&lt;script src=&quot;//cdn.jsdelivr.net/npm/phaser-matter-collision-plugin&quot;&gt;&lt;/script&gt;</code>
</code></pre>
<p>Now you can use the global <code>PhaserMatterCollisionPlugin</code>. See <a href="#usage">usage</a> for how to use the plugin.</p>
<h3 id="as-a-module">As a Module</h3><p>Install via npm:</p>
<pre><code><code class="source-code prettyprint">npm install --save phaser-matter-collision-plugin</code>
</code></pre><p>To use the transpiled and minified distribution of the library:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import PhaserMatterCollisionPlugin from &quot;phaser-matter-collision-plugin&quot;;</code>
</code></pre>
<p>To use the raw library (so you can transpile it to match your own project settings):</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import PhaserMatterCollisionPlugin from &quot;phaser-matter-collision-plugin/src&quot;;</code>
</code></pre>
<p>See <a href="#usage">usage</a> for how to use the plugin.</p>
<h2 id="usage">Usage</h2><h3 id="initial-setup">Initial Setup</h3><p>When setting up your game config, add the plugin:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const config = {
  // ...
  physics: {
    default: &quot;matter&quot;
  },
  // Install the scene plugin
  plugins: {
    scene: [
      {
        plugin: PhaserMatterCollisionPlugin, // The plugin class
        key: &quot;matterCollision&quot;, // Where to store in Scene.Systems, e.g. scene.sys.matterCollision
        mapping: &quot;matterCollision&quot; // Where to store in the Scene, e.g. scene.matterCollision
      }
    ]
  }
};

const game = new Phaser.Game(config);</code>
</code></pre>
<p>Now, within a scene, you can use <code>this.matterCollision</code> to access the plugin instance.</p>
<h3 id="usage-in-scene">Usage in Scene</h3><h4 id="tracking-collisions">Tracking Collisions</h4><p>The plugin has <code>addOnCollideStart</code>, <code>addOnCollideActive</code> and <code>addOnCollideEnd</code> methods which allow you to listen to collisions between &quot;objects&quot; in your scene. Those objects can be: a native Matter body, a tile, a Matter sprite, any object with a <code>body</code> property, or an array of any of those.</p>
<p>For example, game object vs game object collisions:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const player = this.matter.add.sprite(0, 0, &quot;player&quot;);
const trapDoor = this.matter.add.image(200, 0, &quot;door&quot;);

this.matterCollision.addOnCollideStart({
  objectA: player,
  objectB: trapDoor,
  callback: function(eventData) {
    // This function will be invoked any time the player and trap door collide
    const { bodyA, bodyB, gameObjectA, gameObjectB, pair } = eventData;
    // bodyA &amp; bodyB are the Matter bodies of the player and door respectively
    // gameObjectA &amp; gameObjectB are the player and door respectively
    // pair is the raw Matter pair data
  },
  context: this // Context to apply to the callback function
});</code>
</code></pre>
<p>If you omit the <code>objectB</code> property, you&apos;ll get all collisions involving <code>objectA</code>:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const player = this.matter.add.sprite(0, 0, &quot;player&quot;);

this.matterCollision.addOnCollideStart({
  objectA: player,
  callback: eventData =&gt; {
    const { bodyB, gameObjectB } = eventData;
    console.log(&quot;Player touched something.&quot;);
    // bodyB will be the matter body that the player touched
    // gameObjectB will be the game object that owns bodyB, or undefined if there&apos;s no game object
  }
});</code>
</code></pre>
<p>Game object vs Matter sensor:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const player = this.matter.add.sprite(0, 0, &quot;player&quot;);
const sensor = this.matter.world.add.rectangle(100, 0, 50, 50, { isStatic: true, isSensor: true });

this.matterCollision.addOnCollideStart({
  objectA: player,
  objectB: sensor,
  callback: eventData =&gt; console.log(&quot;Player touched hidden sensor&quot;)
});</code>
</code></pre>
<p>Game object vs array of objects:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const player = this.matter.add.sprite(0, 0, &quot;player&quot;);
const enemy1 = this.matter.add.sprite(100, 0, &quot;enemy&quot;);
const enemy2 = this.matter.add.sprite(200, 0, &quot;enemy&quot;);
const enemy3 = this.matter.add.sprite(300, 0, &quot;enemy&quot;);

this.matterCollision.addOnCollideStart({
  objectA: player,
  objectB: [enemy1, enemy2, enemy3],
  callback: eventData =&gt; {
    console.log(&quot;Player hit an enemy&quot;);
    // eventData.gameObjectB will be the specific enemy that was hit!
  }
});</code>
</code></pre>
<p>Or, array vs array:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">this.matterCollision.addOnCollideStart({
  objectA: [player1, player2],
  objectB: [enemy1, enemy2, enemy3],
  callback: eventData =&gt; {
    console.log(&quot;A player hit an enemy&quot;);
    // eventData.gameObjectA will be the specific player involved in the collision
    // eventData.gameObjectB will be the specific enemy involved in the collision
  }
});</code>
</code></pre>
<p>You can listen for collisions vs a single tile (or an array of tiles), but it&apos;s likely more useful to do something like:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">this.matterCollision.addOnCollideStart({
  objectA: player,
  callback: eventData =&gt; {
    const { bodyB, gameObjectB } = eventData;

    if (gameObjectB !== undefined &amp;&amp; gameObjectB instanceof Phaser.Tilemaps.Tile) {
      // Now you know that gameObjectB is a Tile, so you can check the index, properties, etc.
      if (gameObjectB.properties.isDeadly) console.log(&quot;Stepped on deadly tile&quot;);
      else if (gameObjectB.index === 32) console.log(&quot;Stepped on the tile with index 32&quot;);
    }
  }
});</code>
</code></pre>
<p>The plugin also exposes two sets of events via the <code>this.matterCollision.events</code> event emitter:</p>
<ul>
<li>&quot;collisionstart&quot;, &quot;collisionactive&quot;, &quot;collisionend&quot; - these match the Matter events. They emit a single parameter <code>event</code>. Aside from the normal Matter data in <code>event</code>, each pair in <code>event.pairs</code> has a <code>gameObjectA</code> and <code>gameObjectB</code> property that points to the game object that owns each body (if one exists).</li>
<li>&quot;paircollisionstart&quot;, &quot;paircollisionactive&quot;, &quot;paircollisionend&quot; - these are similar to the above, except they fire once for each pair. They have one parameter that looks like this: <code>{ bodyA, bodyB, gameObjectA, gameObjectB, pair }</code></li>
</ul>
<p>You can listen to them via <code>this.matterCollision.events.on(&quot;collisionstart&quot;, ...)</code>.</p>
<h4 id="stop-tracking-collisions">Stop Tracking Collisions</h4><p>You can stop tracking a collision via <code>removeOnCollideStart</code>, <code>removeOnCollideActive</code> and <code>removeOnCollideEnd</code>. They take the same parameters as <code>addOnCollideStart</code>. E.g.:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">function onCollide() {
  console.log(&quot;A player hit an enemy&quot;);
}

// ... after addOnCollideStart has been used

this.matterCollision.removeOnCollideStart({
  objectA: [player1, player2],
  objectB: [enemy1, enemy2, enemy3],
  callback: onCollide
});</code>
</code></pre>
<p>In addition, the addOnCollide methods will also return a function that automatically unsubscribes from the collision event (which can be useful if you use arrow functions):</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const unsubscribe = this.matterCollision.addOnCollideStart({
  objectA: player,
  objectB: trapDoor,
  callback: eventData =&gt; {
    // Do something, like dropping the door out underneath the player
    // Then unsubscribe so this callback is never called again
    unsubscribe();
  }
});</code>
</code></pre>
<p>If you want to remove all listeners that have been added - not just one colliding pair - there are also the following methods:</p>
<ul>
<li><code>removeAllCollideStartListeners</code></li>
<li><code>removeAllCollideActiveListeners</code></li>
<li><code>removeAllCollideEndListeners</code></li>
<li><code>removeAllCollideListeners</code> - removes start, active and end listeners</li>
</ul>
<h2 id="live-examples">Live Examples</h2><p>There&apos;s one example at the moment. You can check it out on CodeSandbox (which uses the plugin imported from npm):</p>
<p><a href="https://codesandbox.io/s/0o0917m23l?module=%2Fjs%2Findex.js"><img src="./manual/./doc-source-assets/collision-plugin-demo.gif" alt=""></a></p>
<p><a href="https://codesandbox.io/s/0o0917m23l?module=%2Fjs%2Findex.js"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit Phaser Matter Collision Plugin Demo 1"></a></p>
<p>Or you can check out the same example, but with the plugin loaded via a CDN in the <a href="https://github.com/mikewesthad/phaser-matter-collision-plugin/tree/master/examples">examples folder</a>.</p>
<p>You can also poke around the <a href="https://github.com/mikewesthad/phaser-matter-collision-plugin/tree/master/tests">&quot;tests&quot; folder</a> of this repository for usage examples.</p>
<p>TODO: add a module example and a script example</p>
<h2 id="development">Development</h2><p>The project is controlled by npm scripts and uses cypress &amp; jest for testing. Cypress is used for end-to-end verification that the plugin works as expected with Phaser. Jest is used for unit testing the plugin (via heavy mocking since Phaser headless mode is not complete).</p>
<ul>
<li>The <code>watch</code> and <code>build</code> tasks will build the plugin source in library/ or the projects in tests/</li>
<li>The <code>serve</code> task opens the whole project (starting at the root) in a server</li>
<li>The <code>dev</code> task will build &amp; watch the library, tests and open up the server. This is useful for creating tests and updating the library.</li>
<li>The <code>dev:cypress</code> task will build &amp; watch the library &amp; tests, as well as open up cypress in headed mode. This is useful for checking out individual tests and debugging them.</li>
<li>The <code>test:cypress</code> task will build the tests and run cypress in headless mode to check all end-to-end tests.</li>
<li>The <code>test:jest</code> will run the jest tests.</li>
</ul>
<h2 id="tests">Tests</h2><p>The cypress tests rely on a particular structure:</p>
<ul>
<li>Each test game inside of &quot;tests/&quot; should have an &quot;index.html&quot; file as the entry point. &quot;src/js/index.js&quot; will be compiled to &quot;build/js/index.js&quot; by webpack. (Cypress doesn&apos;t support <code>type=&quot;module&quot;</code> on scripts, so this is necessary if we need modules.)</li>
<li>Each test has access to <code>test-utils.js</code> which provides <code>startTest</code>, <code>passTest</code> and <code>failTest</code> methods. Call <code>startTest</code> at the beginning and pass/fail when the test passes/fails. This manipulates in the DOM in a way that cypress is expecting.</li>
<li>Each test in &quot;cypress/integration/&quot; simply loads up the specified URL and waits for it to pass or timeout. (Technically, startTest and failTest are ignored, but they are useful for visual inspection of a test.)</li>
</ul>
<p>The jest unit tests rely on a simple mocking of Phaser and Matter. They are stored inside &quot;src/&quot;. Once Phaser headless is available, this testing structure could be re-evaluated.</p>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
